#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

// 아래 설명에 정리했던 것처럼,
// 각 꼭지점 좌표값들로부터 랜덤한 화살표 벡터값을 얻을 수 있는
// vec2 / vec2 랜덤함수가 필요함
vec2 random(vec2 v) {
  // 랜덤한 vec2 값을 뱉어줘야 하니까, vec2의 재료가 될 두 성분 f1, f2를 
  // 현재 픽셀 좌표값인 v와 서로 다른 임의의 vec2값을 내적계산으로 랜덤하게 뽑아줌.
  float f1 = dot(v, vec2(56.37, 67.531));
  float f2 = dot(v, vec2(69.08641, 75.372839)); // f1, f2의 내적계산 각각에 필요한 임의의 vec2 데이터는 그냥 서로 다른 vec2 데이터이기만 하면 됨. 아무 값이나 대충 넣을 것.

  // 성분값 f1, f2를 각각 fract, sin, cos 내장함수를 이용해서 랜덤 vec2 데이터에 넣어줄 x, y값으로 계산해 줌.
  // 이 공식은 이전에 배웠던 랜덤함수에서 사용했던 거와 같음.
  // 이전에 랜덤함수 사용했던 것과 마찬가지로 fract()로 감싸주니까 x, y 각각의 값의 범위는 0 ~ 1 사이겠지
  float x = fract(sin(f1 * 6.7876) * 56423.12312);
  float y = fract(cos(f2 * 1.34531) * 63451.12512);

  // fract()로 계산한 랜덤값 x, y의 범위는 0 ~ 1사이라고 했지?
  // 근데, Gradient Noise의 화살표 벡터를 보면, 0 ~ 1 사이, 즉 0 ~ 90도 사이의 각도만 있는 게 아니라,
  // 180도에 가까운 각도를 가진 화살표도 많잖아?
  // 그러면 x, y의 범위가 화살표 벡터의 각도 범위를 결정하는 역할을 한다면,
  // 그 범위를 -1 ~ 1 사이로 확대해줘야 겠지? 그래서 결과값 vec2에 2를 곱한 뒤 1을 빼줘서 -1 ~ 1 사이의 범위로 Mapping 해준거임.
  return vec2(x, y) * 2. - 1.;
}

// 랜덤함수를 이용해 격자의 각 꼭지점 좌표로부터 랜덤한 vec2 데이터를 받은 뒤,
// Gradient Noise에 필요한 노이즈값을 계산해 줄 노이즈 함수
// 하단에 정리된 내적계산 관련 내용을 제외하면, 이 예제에서 사용할 노이즈 함수도
// Value Noise 에서 사용했던 노이즈 함수와 상당 부분 유사함. shader-noise2 예제를 참고하면서 공부할 것.
float noise(vec2 v) {
  vec2 i = floor(v); // 전달된 픽셀 좌표값의 정수부분만 떼어낸 vec2
  vec2 f = fract(v); // 전달된 픽셀 좌표값의 소수부분만 떼어낸 vec2

  // 전달된 픽셀 좌표 v가 포함된 격자 한 칸의 4개의 꼭지점 좌표값을 구함
  // 참고로, 좌하단 꼭지점 좌표값은 vec2 i와 동일하니 별도로 구할 필요는 없겠지
  vec2 i2 = i + vec2(1., 0.); // 우하단 꼭지점 좌표값
  vec2 i3 = i + vec2(0., 1.); // 좌상단 꼭지점 좌표값
  vec2 i4 = i + vec2(1., 1.); // 우상단 꼭지점 좌표값

  // 각 꼭지점 좌표로부터 랜덤한 vec2 데이터(화살표 벡터값)을 얻음
  // 이 랜덤한 vec2는 범위가 -1 ~ 1이기 때문에, 
  // 결국 꼭지점으로부터 출발하는, '방향값만' 갖는 단위벡터라고도 볼 수 있겠지.
  // 그니까 랜덤한 vec2 데이터 자체가 화살표 벡터값과 동일한 셈. 
  vec2 r = random(i);
  vec2 r2 = random(i2);
  vec2 r3 = random(i3);
  vec2 r4 = random(i4);

  // 섞어주는 비율값 좌표인 vec2 f는 
  // Value noise 에서도 경계선을 뭉개주기 위해 smoothstep으로 곡선 보간 해줬는데, 여기서도 동일하게 해줌.
  // f = smoothstep(0., 1., f);

  // 근데 smoothstep() 으로 경계선을 뭉개줘도 되는데,
  // shader-noise1 예제에서도 사용했던 아래의 공식을 이용하면
  // 노이즈의 곡선이 훨씬 더 완만해지기 때문에 경계선이 더 부드럽게 변할 수 있음.
  f = f * f * f * (f * (f * 6. - 15.) + 10.);

  // 이제 각 꼭지점으로부터 출발하는 화살표 벡터 r, r2, r3, r4와
  // 각 꼭지점에서 현재 픽셀로 향하는 벡터 (ex. 첫 번째 꼭지점의 경우 v - i)를 내적계산함.
  // 각 꼭지점마다 화살표 벡터와 현재 픽셀로 향하는 벡터가 다 다르니 꼭지점마다 결과값을 따로 계산해줘야 겠지
  float d = dot(r, v - i);
  float d2 = dot(r2, v - i2);
  float d3 = dot(r3, v - i3);
  float d4 = dot(r4, v - i4);

  // 이 다음부터는 Value noise와 계산 방식이 비슷함.
  // 각 내적계산 결과값을 f.x 만큼의 비율로 mix해서 bot, top에 넣어주고,
  // bot과 top을 또 f.y 만큼의 비율로 mix 해서 최종적으로 리턴할 노이즈값을 계산함.
  float bot = mix(d, d2, f.x);
  float top = mix(d3, d4, f.x);
  float ret = mix(bot, top, f.y); // 최종 리턴할 노이즈값

  // 그런데 그냥 ret를 리턴해버리면 Gradation noise가 그려지기는 하는데
  // thebookofshader.com 의 예제보다 새카맣게 탄 노이즈 패턴이 그려짐
  // 이게 왜 그러냐면, 애초에 화살표 벡터인 r, r2, r3, r4를 계산할 때
  // -1 ~ 1 사이의 벡터값으로 리턴받기 때문에, 
  // 이 화살표 벡터를 이용한 내적계산도 결과값이 -1 ~ 1 사이의 값으로 나올 수밖에 없고,
  // 그에 따라 내적계산된 결과값들을 mix해준 ret도 
  // -1 ~ 1 사이의 값이 리턴되기 때문에, -1로 리턴된 부분의 색상은 죄다 까만색으로 칠해진 것.
  // 따라서, 리턴해 줄 노이즈값의 범위를 0 ~ 1 사이로 Mapping해주는 작업이 추가로 필요함.
  return ret * 0.5 + 0.5;
}

void main() {
  vec2 coord = gl_FragCoord.xy / u_resolution; // 각 픽셀들 좌표값 normalize
  coord *= 10.; // 좌표계(격자)를 0 ~ 1 에서 0 ~ 10으로 Mapping해서 확대함.
  coord.x *= u_resolution.x / u_resolution.y; // 캔버스를 resizing 해도 왜곡이 없도록 좌표값에 해상도비율값 곰해줌.

  vec3 col = vec3(noise(coord));

  gl_FragColor = vec4(col, 1.);
}

/*
  Gradient Noise 에서 필요한 내적계산


  내적이란 두 벡터를 기준으로 계산하며,
  두 벡터의 사잇각의 cos 값과 두 벡터의 norm(크기값 = 길이값)을 곱한 값으로 계산할 수 있음.
  또는, 각 벡터의 성분값끼리 곱한 뒤에, 결과값을 합산하여 계산할 수도 있음. 
  
  1. 내적 결과값 / 두 벡터의 크기값의 곱(즉 두 벡터의 길이를 곱한 값) 해주거나,
  2. 또는 두 벡터의 크기값이 1이라는 가정 하에,

  -두 벡터의 사잇각이 0도에 가까울수록 내적의 결과값은 1에 가까워지고,
  -두 벡터의 사잇각이 90도에 가까울수록 내적의 결과값은 0에 가까워지고,
  -두 벡터의 사잇각이 180도에 가까울수록 내적의 결과값은 -1에 가까워짐.


  다만, 위에 내용은 각 벡터를 normalize 했을 때의 얘기이고,
  만약 위의 1번과 2번의 조건 어느 하나도 만족하지 못하는 경우라면,

  -두 벡터의 사잇각이 90도와 0도 사이면 내적의 결과값은 양수이고,
  -두 벡터의 사잇각이 90도면 내적의 결과값은 0이고,
  -두 벡터의 사잇각이 180도와 90도 사이면 내적의 결과값은 음수이다.

  이게 왜 이러냐면, 두 벡터를 normalize 하지 않았으니 내적의 최대값과 최소값이 각각 
  1이 아니면서 절댓값이 동일한 두 음수와 양수로 나오게 되니까 
  위의 결과가 나오게 되는거지. 


  어쨋든 결론적으로 내적의 결과값이 무엇을 의미하는거냐?
  이에 대한 해석은 여러가지가 있을 수 있지만,
  가장 핵심적인 거는, 
  
  "두 벡터의 사잇각이 이루는 각의 크기에 따라서
  1부터 -1까지 cos 그래프를 그리면서 값이 변화한다."

  라는 개념만 확실히 알고 있으면 됨.
*/

/*
  Value Noise 는 좀 blocky 한 반면,
  Gradient Noise 는 모양이 흐물흐물하고 예쁘게 나타날 수 있었던 이유
  

  value-noise-vs-gradient-noise.png 이미지를 보면,
  value noise는 blocky한 느낌이 아직 남아있는 반면,
  gradient는 굉장히 흐물흐물한 느낌으로 경계선이 뭉개진 것을 볼 수 있음.

  이거는 gradient noise가 노이즈값을 구하는 공식이 다르기 때문인데,
  gradient noise에 보이는, 각 격자의 꼭지점 부분에서 뻗어나오는 화살표가 중요한 요소임.

  이 화살표가 뭐냐면,
  각 격자의 꼭지점의 좌표값인 vec2 데이터를
  vec2 / vec2 랜덤함수에 넣어줘서 랜덤한 vec2 데이터를 리턴받겠지?
  이때, 이 랜덤한 vec2는 -1 ~ 1 사이의 좌표값으로 리턴받도록 할 것이기 때문에,
  
  랜덤한 vec2는 결국 
  꼭지점에서 출발하면서, '방향값만 갖는' normalize 된 상태의 벡터라고 할 수 있겠지!
  한마디로 말하자면, 랜덤한 vec2 자체가 곧 화살표 벡터라는거임!

  1. 꼭지점에서 출발하는 랜덤한 화살표 벡터값과 (즉, 랜덤함수로 얻은 vec2 벡터값) 
  2. 해당 꼭지점 ~ 현제 픽셀의 좌표 를 연결한 벡터를 
  내적계산한 결과값을 이용해서 노이즈를 만들어낸다.

  그래서 1번과 2번 벡터의 사잇각이 
  0도에 가까울수록 1에 가까운 값을 리턴해서 밝은 색상값을 찍어주고,
  0도에서 멀어질수록 0에 가까운 값을 리턴해서 어두운 색상값을 찍어주는 원리임.

  그렇게 되면, 이 화살표 벡터와 가까운 각도의 픽셀들은 밝은 값이 찍힐 것이고,
  이 화살표 벡터와 먼 각도의 픽셀들일수록 어두운 값이 찍히게 되겠지.
  화살표 벡터 방향과 가까울수록 밝게 보이는 노이즈가 생성되는거임.

  이때, 화살표의 방향이
  랜덤함수로부터 중구난방의 방향을 갖도록 vec2 데이터를 리턴받기 때문에,
  Value noise처럼 격자 또는 blocky한 방향이 아닌,
  좀 더 다양한 방향으로 흐물흐물한 노이즈를 생성할 수 있는 것임. 

  바로 이 차별점 덕분에 Value noise보다 
  organic하고 흐물흐물한 노이즈를 발생시킬 수 있었던 것임. 
*/